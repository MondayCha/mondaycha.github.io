---
title: çº¿æ®µæ ‘
created_at: 2023-09-29
is_public: true
tags:
  - leetcode
---

```ad-note
### é¢˜å•

[çº¿æ®µæ ‘è¯¦è§£ã€Œæ±‡æ€»çº§åˆ«æ•´ç† ğŸ”¥ğŸ”¥ğŸ”¥ã€](https://leetcode.cn/problems/range-module/solutions/1612955/by-lfool-eo50/)
```

## 715. Range æ¨¡å—

C++ ä¸­çš„ `map` åº•å±‚æ˜¯å¹³è¡¡äºŒå‰æ ‘ï¼Œå¥‘åˆçº¿æ®µæ ‘çš„æ•°æ®ç»“æ„ã€‚

```cpp
class RangeModule {
private:
    map<int, int> intervals;
public:
    RangeModule() {}

    void addRange(int left, int right) {
        auto it = intervals.upper_bound(left);
        if (it != intervals.begin()) {
            // not empty
            auto prev_it = prev(it);
            if (prev_it->second >= right) {
                return;
            }
            if (prev_it->second >= left) {
                left = prev_it->first;
                intervals.erase(prev_it);
            }
        }
        while (it != intervals.end() && it->first <= right) {
            right = max(right, it->second);
            it = intervals.erase(it);
        }
        intervals[left] = right;
    }

    bool queryRange(int left, int right) {
        auto it = intervals.upper_bound(left);
        if (it == intervals.begin()) {
            // empty
            return false;
        }
        auto prev_it = prev(it);
        return right <= prev_it->second;
    }

    void removeRange(int left, int right) {
        auto it = intervals.upper_bound(left);
        if (it != intervals.begin()) {
            // not empty
            auto prev_it = prev(it);
            int prev_right = prev_it->second;
            if (prev_right >= right) {
                if (prev_it->first == left) {
                    intervals.erase(prev_it);
                } else {
                    prev_it->second = left;
                }
                if (prev_right > right) {
                    intervals[right] = prev_right;
                }
                return;
            } else if (prev_right > left) {
                if (prev_it->first == left) {
                    intervals.erase(prev_it);
                } else {
                    prev_it->second = left;
                }
            }
        }
        while (it != intervals.end() && it->first < right) {
            if (it->second <= right) {
                it = intervals.erase(it);
            } else {
                intervals[right] = it->second;
                intervals.erase(it);
                return;
            }
        }
    }
};
```

## 729. æˆ‘çš„æ—¥ç¨‹å®‰æ’è¡¨ I

```cpp
class MyCalendar {
private:
    map<int, int> intervals;
public:
    MyCalendar() {}

    bool book(int start, int end) {
        auto it = intervals.upper_bound(start);
        if (it != intervals.begin()) {
            auto last_it = prev(it);
            if (last_it->second > start) {
                return false;
            }
        }
        if (it != intervals.end()) {
            if (it->first < end) {
                return false;
            }
        }
        intervals[start] = end;
        return true;
    }
};
```

## 731. æˆ‘çš„æ—¥ç¨‹å®‰æ’è¡¨ II

å…³äº Pair é‡Œçš„å…ƒç´ å«ä¹‰ï¼š

- `first` æ˜¯åŒºé—´æœ€å¤§å€¼ï¼Œ`second` æ˜¯æ‡’æ ‡è®°ã€‚
- `second`Â  åªæœ‰ç»™å®šç´¢å¼•åŒºé—´å…¨è¦†ç›–æ—¶æ‰ä¼š Â `+= val`ï¼Œè€Œå…¨è¦†ç›–çš„æƒ…å†µå¯èƒ½å‘ç”Ÿåœ¨é•¿åŒºé—´æˆ–çŸ­åŒºé—´ä¸Š
- æ¯æ¬¡æ·»åŠ  Â `val`Â  éƒ½ä¼šåˆ†å¸ƒåœ¨ä¸åŒçš„ Â `idx`(å±‚æ•°æœ‰é«˜æœ‰ä½ï¼ŒæŸä¸ª Â `idx`Â  æœ‰åŠ ï¼Œä»–çš„å­©å­å¯èƒ½ä¹‹å‰ä¹Ÿæœ‰åŠ ) çš„ Â `second`Â  ä¸Šï¼Œéœ€è¦æ¯ä¸ª Â `idx`Â  ç»´æŠ¤ä¸€ä¸ª Â `first`Â  æ¥æ ‡è¯†è¯¥ Â `idx`Â  ä¸‹ç´¢å¼•åŒºé—´çš„æœ€å¤§å€¼ã€‚

```cpp
class MyCalendarTwo {
    unordered_map<int, pair<int, int>> tree;
public:
    MyCalendarTwo() {}

    void update(int start, int end, bool isAdd, int l, int r, int index) {
        int val = isAdd ? 1 : -1;
        if (r < start || l > end) {
            return;
        }
        if (start <= l && r <= end) {
            tree[index].first += val;
            tree[index].second += val;
        } else {
            int mid = (l + r) >> 1;
            update(start, end, isAdd, l, mid, 2 * index);
            update(start, end, isAdd, mid + 1, r, 2 * index + 1);
            tree[index].first = tree[index].second + max(tree[2 * index].first, tree[2 * index + 1].first);
        }
    }

    bool book(int start, int end) {
        update(start, end - 1, true, 0, 1e9, 1);
        if (tree[1].first > 2) {
            update(start, end - 1, false, 0, 1e9, 1);
            return false;
        }
        return true;
    }
};

/**
 * Your MyCalendarTwo object will be instantiated and called as such:
 * MyCalendarTwo* obj = new MyCalendarTwo();
 * bool param_1 = obj->book(start,end);
 */
```
